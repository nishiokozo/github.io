// 2021/07/02	ver1.09 geom 2021/07/02 vec2追加 gra_create 追加
// 2021/05/28	ver1.08	行列式のコメント追加
// 2021/05/26	ver1.07	minvers再びアルゴリズム交換
// 2021/05/25	ver1.06	minvers別のアルゴリズムに交換
// 2021/05/24	ver1.05	行列のコメントを修正
// 2021/05/23	ver1.04	列優先バグ修正vec4->vec3
// 2021/05/17	ver1.03	mrotx / vrotx 等、名称変更
// 2021/05/09	ver1.02	minverts追加、mlookat変更
// 2021/05/07	ver1.01	デバッグ、vec3対応
// 2021/05/06	ver1.00	分離
//
//	行列ライブラリコンセプト
//	GLSLと同じ数式同じ行列がメインプログラムでも同様に機能する
//
// OpenGL® Programming Guide: The Official Guide 
// https://www.cs.utexas.edu/users/fussell/courses/cs354/handouts/Addison.Wesley.OpenGL.Programming.Guide.8th.Edition.Mar.2013.ISBN.0321773039.pdf

//-----------------------------------------------------------------------------
function gra_create( cv )	//2021/06/01
//-----------------------------------------------------------------------------
{
	let gra={}
	gra.ctx=cv.getContext('2d');
	gra.x = 0;
	gra.y = 0;

	gra.sx = 0; 
	gra.sy = 0; 
	gra.ex = gra.ctx.canvas.width; 
	gra.ey = gra.ctx.canvas.height; 
	let ox = 0;
	let oy = 0;

	gra.col = "#000000";

	//-------------------------------------------------------------------------
	gra.window = function( _sx, _sy, _ex, _ey )
	//-------------------------------------------------------------------------
	{
		gra.sx = _sx;
		gra.sy = _sy;
		gra.ex = _ex;
		gra.ey = _ey;
		ox = -_sx;
		oy = -_sy;
	}

	function win_abs( x, y )
	{
		let w = gra.ex-gra.sx;
		let h = gra.ey-gra.sy;
		x = (x+ox)/w * gra.ctx.canvas.width;
		y = (y+oy)/h * gra.ctx.canvas.height;
		return [x,y];
	}
	function win_range( x, y )
	{
		let w = Math.abs(gra.ex-gra.sx);
		let h = Math.abs(gra.ey-gra.sy);
		x = (x)/w * gra.ctx.canvas.width;
		y = (y)/h * gra.ctx.canvas.height;
		return [x,y];
	}
	//-------------------------------------------------------------------------
	gra.line = function( x1, y1, x2, y2, mode="" )
	//-------------------------------------------------------------------------
	{
		function func( sx,sy, ex,ey, style =[1] )
		{
			gra.ctx.beginPath();
			gra.ctx.setLineDash(style);
			gra.ctx.strokeStyle = gra.col;
//			gra.ctx.strokeStyle = "#000000";
			gra.ctx.lineWidth = 1.0;
			gra.ctx.moveTo( sx, sy );
			gra.ctx.lineTo( ex, ey );
			gra.ctx.closePath();
			gra.ctx.stroke();
		}

		[x1,y1]=win_abs(x1,y1);
		[x2,y2]=win_abs(x2,y2);

		let style = [];
		switch( mode )
		{
			case "hasen": style = [2,4];
		}
	
		func( x1, y1, x2, y2, style );
	}
	//-------------------------------------------------------------------------
	gra.locate = function( x1, y1 )
	//-------------------------------------------------------------------------
	{
		gra.x=x1*6;
		gra.y=y1*16;
	}
	//-------------------------------------------------------------------------
	gra.print = function( str, x1=gra.x, y1=gra.y )
	//-------------------------------------------------------------------------
	{
		function func( str, tx, ty )
		{
			gra.ctx.font = "12px monospace";
			gra.ctx.fillStyle = gra.col;
			gra.ctx.fillText( str, tx+2, ty+16 );

		}

		[x1,y1]=win_abs(x1,y1);
		func( str, x1, y1 );

			gra.x = x1;
			gra.y = y1+16;
	}
	//-----------------------------------------------------------------------------
	gra.color = function( fr=0.0, fg=0.0, fb=0.0 )
	//-----------------------------------------------------------------------------
	{
		let r = fr*255;
		let g = fg*255;
		let b = fb*255;
		if ( r > 255 ) r = 255;
		if ( g > 255 ) g = 255;
		if ( b > 255 ) b = 255;
		let c = (r<<16)+(g<<8)+(b<<0);
		
		let s = "#"+("000000"+c.toString(16)).substr(-6);
		gra.col = s;

//		gra.ctx.fillStyle = s;
//		gra.ctx.strokeStyle = s;
	}
	
	//-----------------------------------------------------------------------------
	gra.circle = function( x1,y1,r )
	//-----------------------------------------------------------------------------
	{
		let func = function( x,y,rw,rh )
		{
			gra.ctx.beginPath();
			gra.ctx.setLineDash([]);
			gra.ctx.strokeStyle = gra.col;
			let rotation = 0;
			let startAngle = 0;
			let endAngle = Math.PI*2;
			gra.ctx.ellipse( x, y, rw, rh, rotation, startAngle, endAngle );
			gra.ctx.closePath();
			gra.ctx.stroke();
		};
		[x1,y1]=win_abs(x1,y1);
		let [rw,rh] = win_range(r,r);
		func( x1, y1,rw,rh );
	}

	//-----------------------------------------------------------------------------
	gra.cls = function()
	//-----------------------------------------------------------------------------
	{
		gra.ctx.fillStyle = "#ffffff";
		gra.ctx.fillRect( 0, 0, gra.ctx.canvas.width, gra.ctx.canvas.height );
		gra.x=0;
		gra.y=0;
	}
	return gra;
};

///// geom 2021/07/02 vec2追加

//------------------------------------------------------------------------------
function vec2( x, y )	// 2021/05/28新規追加
//------------------------------------------------------------------------------
{
	return {x:x, y:y};
}
//------------------------------------------------------------------------------
function vsub2( a, b )
//------------------------------------------------------------------------------
{
	return vec2(
		a.x - b.x,
		a.y - b.y 
	);
}
//------------------------------------------------------------------------------
function vadd2( a, b )
//------------------------------------------------------------------------------
{
	return vec2(
		a.x + b.x,
		a.y + b.y 
	);
}
//------------------------------------------------------------------------------
function vmul2( a, b )
//------------------------------------------------------------------------------
{
	return vec2(
		a.x * b.x,
		a.y * b.y 
	);
}
//------------------------------------------------------------------------------
function reflect2( I, N )
//------------------------------------------------------------------------------
{
	let d = 2*(I.x*N.x + I.y*N.y);
 	return vsub2( I , vec2( d*N.x, d*N.y ) );
}
//------------------------------------------------------------------------------
function vmul_scalar2( a, s )
//------------------------------------------------------------------------------
{
	return vec2(
		a.x * s,
		a.y * s 
	);
}
//------------------------------------------------------------------------------
function vneg2( a )
//------------------------------------------------------------------------------
{
	return vec2( -a.x, -a.y );
}
//------------------------------------------------------------------------------
function dot2( a, b )
//------------------------------------------------------------------------------
{
	return a.x*b.x + a.y*b.y;
}

//------------------------------------------------------------------------------
function length2( v )	//	 as abs()
//------------------------------------------------------------------------------
{
	return Math.sqrt(v.x*v.x+v.y*v.y);
}
//------------------------------------------------------------------------------
function vcopy2( v )
//------------------------------------------------------------------------------
{
	return vec2(v.x,v.y);
}
//------------------------------------------------------------------------------
function normalize2( v )
//------------------------------------------------------------------------------
{
	if ( v.x == 0 && v.y == 0 ) return vec2(0,0);
	let s = 1/Math.sqrt( v.x*v.x + v.y*v.y );
	return vec2(
		v.x * s,
		v.y * s
	);
}



///// geom 2021/05/07 vec3対応

//-----------------------------------------------------------------------------
function radians( v )
//-----------------------------------------------------------------------------
{
	return v/180*Math.PI;
}
//-----------------------------------------------------------------------------
function degrees( v )
//-----------------------------------------------------------------------------
{
	return v*180/Math.PI;
}
function vec3( x, y, z )	// 2021/05/06 クラスを止めて配列化
{
	return {x:x, y:y, z:z};
}
function vec4( x, y, z,w )	// 2021/05/06 クラスを止めて配列化
{
	return {x:x, y:y, z:z, w:w};
}
//------------------------------------------------------------------------------
function dot( a, b )
//------------------------------------------------------------------------------
{
	return a.x*b.x + a.y*b.y + a.z*b.z;
}
//------------------------------------------------------------------------------
function cross( a, b )
//------------------------------------------------------------------------------
{
	return vec3(
		a.y*b.z-a.z*b.y,
		a.z*b.x-a.x*b.z,
		a.x*b.y-a.y*b.x
	);
}
//------------------------------------------------------------------------------
function length( v )
//------------------------------------------------------------------------------
{
	return Math.sqrt( v.x*v.x + v.y*v.y + v.z*v.z );
}

//------------------------------------------------------------------------------
function normalize( v )
//------------------------------------------------------------------------------
{
	let s = 1/Math.sqrt( v.x*v.x + v.y*v.y + v.z*v.z );
	return vec3(
		v.x * s,
		v.y * s,
		v.z * s
	);
}

//------------------------------------------------------------------------------
function vadd( a, b )
//------------------------------------------------------------------------------
{
	return vec3( 
		a.x +b.x,
		a.y +b.y,
		a.z +b.z
	);
}
//------------------------------------------------------------------------------
function vsub( a, b )
//------------------------------------------------------------------------------
{
	return vec3( 
		a.x -b.x,
		a.y -b.y,
		a.z -b.z
	);
}
//------------------------------------------------------------------------------
function vmul( a, b )
//------------------------------------------------------------------------------
{
	return vec3( 
		a.x *b.x,
		a.y *b.y,
		a.z *b.z
	);
}
//------------------------------------------------------------------------------
function vdiv( a, b )
//------------------------------------------------------------------------------
{
	return vec3( 
		a.x /b.x,
		a.y /b.y,
		a.z /b.z
	);
}
//------------------------------------------------------------------------------
function vmax( a, b )
//------------------------------------------------------------------------------
{
	return vec3( 
		Math.max(a.x,b.x),
		Math.max(a.y,b.y),
		Math.max(a.z,b.z)
	);
}
//------------------------------------------------------------------------------
function vmin( a, b )
//------------------------------------------------------------------------------
{
	return vec3( 
		Math.min(a.x,b.x),
		Math.min(a.y,b.y),
		Math.min(a.z,b.z)
	);
}
//------------------------------------------------------------------------------
function reflect( I, N )
//------------------------------------------------------------------------------
{
	let a = 2*dot(I,N);
 	return vsub( I , vmul( vec3(a,a,a), N ) );
}
//------------------------------------------------------------------------------
function refract( I, N, eta )
//------------------------------------------------------------------------------
{
	let R = vec3(0,0,0);
	let k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
	if ( k < 0.0 )
	{
		R = vec3(0,0,0);
	}
	else
	{
	//	R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;
		let ve = vec3(eta,eta,eta);
		let a = vmul( ve , I ); 
		let b = eta * dot(N, I);
		let c = b + Math.sqrt(k);
		let d = vmul( vec3(c,c,c) , N);
		R = vsub(a , d);

	}
	return R;
}

function mat4(		// 2021/05/06 二次元配列化
		m00,m01,m02,m03,
		m10,m11,m12,m13,
		m20,m21,m22,m23,
		m30,m31,m32,m33)
{
	return [
		[m00,m01,m02,m03],
		[m10,m11,m12,m13],
		[m20,m21,m22,m23],
		[m30,m31,m32,m33]
	];
}


//---------------------------------------------------------------------
function mperspective( fovy, aspect, n, f ) // 2021/05/04 GLに準拠
//---------------------------------------------------------------------
{
	// n : ニアクリップ、必ず正の値を指定	= 視点から投影面までの距離
	// f : ファークリップ、必ず正の値を指定
	// gluPerspective
  	//
	//	Y-up
	//	Z奥がマイナス

    let y = n * Math.tan(fovy * Math.PI / 360.0);
    let x = y * aspect;

	return mfrustum( -x, x, -y, y, n, f );
}

//---------------------------------------------------------------------
function mfrustum( l, r, b, t, n, f ) //2021/05/04 GLに準拠
//---------------------------------------------------------------------
{
	// glFrustum(-1.0, 1.0, -1.0, 1.0, 1.5, 20.0);
  	//
	//	Y-up
	//	Z奥がマイナス

	return mat4(
		2*n/(r-l)	,	0			,	0				,	0	,
			0		,	2*n/(t-b)	,	0				,	0	,
		(r+l)/(r-l)	,	(t+b)/(t-b)	,	-(f+n)/(f-n)	,	-1	,
			0		,	0			,	-(2*f*n)/(f-n)	,	0	);
}
//---------------------------------------------------------------------
function mortho ( l, r, b, t, n, f ) //GL 準拠
//---------------------------------------------------------------------
{
	// glOrtho(-2.0, 2.0, -2.0, 2.0, -1.5, 1.5);
	//
	//	Y-up
	//	Z奥がマイナス

	let tx =  -(r+l)/(r-l);
	let ty =  -(t+b)/(t-b);
	let tz =  -(f+n)/(f-n);

	return mat4(
		2/(r-l)		,	0			,	0			,	0			,
		0			,	2/(t-b)		,	0			,	0			,
		0			,	0			,	-2/(f-n)	,	0			,
		tx			,	ty			,	tz			,	1			);
}
//---------------------------------------------------------------------
function midentity() 
//---------------------------------------------------------------------
{
	//	|	1	0	0	0	|	// 数学的表記
	//	|	0	1	0	0	|
	//	|	0	0	1	0	|
	//	|	0	0	0	1	|
	return mat4(
		1	,	0	,	0	,	0	,
		0	,	1	,	0	,	0	,
		0	,	0	,	1	,	0	,
		0	,	0	,	0	,	1	
	);
}
//---------------------------------------------------------------------
function mtrans( v )	// GL準拠＆列優先
//---------------------------------------------------------------------
{
	//	|	1	0	0	x	|	// 数学的表記
	//	|	0	1	0	y	|
	//	|	0	0	1	z	|
	//	|	0	0	0	1	|
	return mat4(
		1	,	0	,	0	,	0	,
		0	,	1	,	0	,	0	,
		0	,	0	,	1	,	0	,
		v.x	,	v.y	,	v.z	,	1	
	);
}
//---------------------------------------------------------------------
function mscale( v )	// 2021/05/06 GL準拠＆列優先
//---------------------------------------------------------------------
{
	//	|	x	0	0	0	|	// 数学的表記
	//	|	0	y	0	0	|
	//	|	0	0	z	0	|
	//	|	0	0	0	1	|
	return mat4(
		v.x	,	0	,	0	,	0	,
		0	,	v.y	,	0	,	0	,
		0	,	0	,	v.z	,	0	,
		0	,	0	,	0	,	1	
	);
}
//---------------------------------------------------------------------
function mrotx( th )	// 右ねじ	GL準拠
//---------------------------------------------------------------------
{
	//	|	1		0		0		0	|	// 数学的表記
	//	|	0		cosθ	-s		0	|
	//	|	0		sinθ	cosθ	0	|
	//	|	0		0		0		1	|
	let c = Math.cos(th);
	let s = Math.sin(th);
	return mat4(	// GL準拠＆列優先 
		1	,	0	,	0	,	0	,
		0	,	c	,	s	,	0	,
		0	,	-s	,	c	,	0	,
		0	,	0	,	0	,	1	
	);
}
//---------------------------------------------------------------------
function mroty( th )	// 右ねじ	GL準拠
//---------------------------------------------------------------------
{
	//	|	cosθ	0		sinθ	0	|	// 数学的表記
	//	|	0		1		0		0	|
	//	|	-sinθ	0		cosθ	0	|
	//	|	0		0		0		1	|
	let c = Math.cos(th);
	let s = Math.sin(th);
	return mat4(	// GL準拠＆列優先
		c	,	0	,	-s	,	0	,
		0	,	1	,	0	,	0	,
		s	,	0	,	c	,	0	,
		0	,	0	,	0	,	1	
	);
}
//---------------------------------------------------------------------
function mrotz( th )	// 右ねじ	GL準拠
//---------------------------------------------------------------------
{
	//	|	cosθ	-sinθ	0		0	|	// 数学的表記
	//	|	sinθ	cosθ	0		0	|
	//	|	0		0		1		0	|
	//	|	0		0		0		1	|
	let c = Math.cos(th);
	let s = Math.sin(th);
	return mat4(	// GL準拠＆列優先 
		c	,	s	,	0	,	0	,
		-s	,	c	,	0	,	0	,
		0	,	0	,	1	,	0	,
		0	,	0	,	0	,	1	
	);
}
//---------------------------------------------------------------------
function mrotate( th, axis ) // 2021/05/06 回転行列だけを返す
//---------------------------------------------------------------------
{

	let {x,y,z} = normalize( axis );
	let s = Math.sin(th);
	let c = Math.cos(th);
	let q = 1-c;

	return mat4(
		x*x*q+c		,	y*x*q+z*s	,	z*x*q-y*s	,	0	,
		x*y*q-z*s	,	y*y*q+c		,	z*y*q+x*s	,	0	,
		x*z*q+y*s	,	y*z*q-x*s	,	z*z*q+c		,	0	,
		0			,	0			,	0			,	1	);
}
//---------------------------------------------------------------------
function mmul( A, B )  //  A X B 列優先
//---------------------------------------------------------------------
{
	//	|	00	10	20	30	|		|	00	10	20	30	|	// 数学的表記
	//	|	01	11	21	31	|	X	|	01	11	21	31	|
	//	|	02	12	22	32	|		|	02	12	22	32	|
	//	|	03	13	23	33	|		|	03	13	23	33	|

	return mat4(
		A[0][0] * B[0][0] +  A[1][0] * B[0][1] +  A[2][0] * B[0][2] +  A[3][0] * B[0][3],
		A[0][1] * B[0][0] +  A[1][1] * B[0][1] +  A[2][1] * B[0][2] +  A[3][1] * B[0][3],
		A[0][2] * B[0][0] +  A[1][2] * B[0][1] +  A[2][2] * B[0][2] +  A[3][2] * B[0][3],
		A[0][3] * B[0][0] +  A[1][3] * B[0][1] +  A[2][3] * B[0][2] +  A[3][3] * B[0][3],

		A[0][0] * B[1][0] +  A[1][0] * B[1][1] +  A[2][0] * B[1][2] +  A[3][0] * B[1][3],
		A[0][1] * B[1][0] +  A[1][1] * B[1][1] +  A[2][1] * B[1][2] +  A[3][1] * B[1][3],
		A[0][2] * B[1][0] +  A[1][2] * B[1][1] +  A[2][2] * B[1][2] +  A[3][2] * B[1][3],
		A[0][3] * B[1][0] +  A[1][3] * B[1][1] +  A[2][3] * B[1][2] +  A[3][3] * B[1][3],

		A[0][0] * B[2][0] +  A[1][0] * B[2][1] +  A[2][0] * B[2][2] +  A[3][0] * B[2][3],
		A[0][1] * B[2][0] +  A[1][1] * B[2][1] +  A[2][1] * B[2][2] +  A[3][1] * B[2][3],
		A[0][2] * B[2][0] +  A[1][2] * B[2][1] +  A[2][2] * B[2][2] +  A[3][2] * B[2][3],
		A[0][3] * B[2][0] +  A[1][3] * B[2][1] +  A[2][3] * B[2][2] +  A[3][3] * B[2][3],

		A[0][0] * B[3][0] +  A[1][0] * B[3][1] +  A[2][0] * B[3][2] +  A[3][0] * B[3][3],
		A[0][1] * B[3][0] +  A[1][1] * B[3][1] +  A[2][1] * B[3][2] +  A[3][1] * B[3][3],
		A[0][2] * B[3][0] +  A[1][2] * B[3][1] +  A[2][2] * B[3][2] +  A[3][2] * B[3][3],
		A[0][3] * B[3][0] +  A[1][3] * B[3][1] +  A[2][3] * B[3][2] +  A[3][3] * B[3][3]
	);
}



/*
//----------------------------------------------------------
function	minvers( M ) // 変換ミスがいくつかあった
//----------------------------------------------------------
{
	let z1=4;  //配列の次数

	let A = midentity();
	for( let i = 0 ; i < z1 ; i++ ) 
	for( let j = 0 ; j < z1 ; j++ ) 
	A[i][j]=M[i][j];// 配列コピー

//	A = M.concat();	// 配列コピー
	
	let I = midentity();
	

	//掃き出し法
	for( let i = 0 ; i < z1 ; i++ )
	{
		let f =1/A[i][i];
		for( let j = 0 ; j < z1 ; j++ )
		{
			A[i][j] *= f;
			I[i][j] *= f;
		}
		for( let j = 0 ; j < z1 ; j++ )
		{
			if( i !=j )
			{
				f= A[j][i];
				for( let k = 0 ; k < z1 ; k++ )
				{
					A[j][k] -= A[i][k]*f;
					I[j][k] -= I[i][k]*f;
				}
			}
		}
	}
	return	I;
}
*/
//----------------------------------------
function minvers( M ) // 20_01/05/25 別のアルゴリズムに交換
//----------------------------------------
{

	// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm

	let	m00 = M[0][0], m01 = M[0][1], m02 = M[0][2], m03 = M[0][3];
	let	m10 = M[1][0], m11 = M[1][1], m12 = M[1][2], m13 = M[1][3];
	let	m20 = M[2][0], m21 = M[2][1], m22 = M[2][2], m23 = M[2][3];
	let	m30 = M[3][0], m31 = M[3][1], m32 = M[3][2], m33 = M[3][3];

	let	a00 = m21 * m32 * m13 - m31 * m22 * m13 + m31 * m12 * m23 - m11 * m32 * m23 - m21 * m12 * m33 + m11 * m22 * m33;
	let	a10 = m30 * m22 * m13 - m20 * m32 * m13 - m30 * m12 * m23 + m10 * m32 * m23 + m20 * m12 * m33 - m10 * m22 * m33;
	let	a20 = m20 * m31 * m13 - m30 * m21 * m13 + m30 * m11 * m23 - m10 * m31 * m23 - m20 * m11 * m33 + m10 * m21 * m33;
	let	a30 = m30 * m21 * m12 - m20 * m31 * m12 - m30 * m11 * m22 + m10 * m31 * m22 + m20 * m11 * m32 - m10 * m21 * m32;

	let det = m00 * a00 + m01 * a10 + m02 * a20 + m03 * a30;

	if ( det == 0 ) 
	{
		let msg = "err minvert";
		console.warn(msg);
		return midentity();
	}
	
	let invd = 1 / det;

	return mat4(
		a00 * invd,
		( m31 * m22 * m03 - m21 * m32 * m03 - m31 * m02 * m23 + m01 * m32 * m23 + m21 * m02 * m33 - m01 * m22 * m33 ) * invd,
		( m11 * m32 * m03 - m31 * m12 * m03 + m31 * m02 * m13 - m01 * m32 * m13 - m11 * m02 * m33 + m01 * m12 * m33 ) * invd,
		( m21 * m12 * m03 - m11 * m22 * m03 - m21 * m02 * m13 + m01 * m22 * m13 + m11 * m02 * m23 - m01 * m12 * m23 ) * invd,
		a10 * invd,
		( m20 * m32 * m03 - m30 * m22 * m03 + m30 * m02 * m23 - m00 * m32 * m23 - m20 * m02 * m33 + m00 * m22 * m33 ) * invd,
		( m30 * m12 * m03 - m10 * m32 * m03 - m30 * m02 * m13 + m00 * m32 * m13 + m10 * m02 * m33 - m00 * m12 * m33 ) * invd,
		( m10 * m22 * m03 - m20 * m12 * m03 + m20 * m02 * m13 - m00 * m22 * m13 - m10 * m02 * m23 + m00 * m12 * m23 ) * invd,
		a20 * invd,
		( m30 * m21 * m03 - m20 * m31 * m03 - m30 * m01 * m23 + m00 * m31 * m23 + m20 * m01 * m33 - m00 * m21 * m33 ) * invd,
		( m10 * m31 * m03 - m30 * m11 * m03 + m30 * m01 * m13 - m00 * m31 * m13 - m10 * m01 * m33 + m00 * m11 * m33 ) * invd,
		( m20 * m11 * m03 - m10 * m21 * m03 - m20 * m01 * m13 + m00 * m21 * m13 + m10 * m01 * m23 - m00 * m11 * m23 ) * invd,
		a30 * invd,
		( m20 * m31 * m02 - m30 * m21 * m02 + m30 * m01 * m22 - m00 * m31 * m22 - m20 * m01 * m32 + m00 * m21 * m32 ) * invd,
		( m30 * m11 * m02 - m10 * m31 * m02 - m30 * m01 * m12 + m00 * m31 * m12 + m10 * m01 * m32 - m00 * m11 * m32 ) * invd,
		( m10 * m21 * m02 - m20 * m11 * m02 + m20 * m01 * m12 - m00 * m21 * m12 - m10 * m01 * m22 + m00 * m11 * m22 ) * invd);

}
//---------------------------------------------------------------------
function vec4_vmul_vM( v, M ) // 列優先 
//---------------------------------------------------------------------
{
	//					|	00	10	20	30	|		// 数学的表記
	//	| x y z w |	 X	|	01	11	21	31	|
	//					|	02	12	22	32	|
	//					|	03	13	23	33	|

	return vec4(
		v.x * M[0][0] +  v.y * M[0][1] +  v.z * M[0][2] +  v.w * M[0][3] ,
		v.x * M[1][0] +  v.y * M[1][1] +  v.z * M[1][2] +  v.w * M[1][3] ,
		v.x * M[2][0] +  v.y * M[2][1] +  v.z * M[2][2] +  v.w * M[2][3] ,
		v.x * M[3][0] +  v.y * M[3][1] +  v.z * M[3][2] +  v.w * M[3][3]
	);
}
//---------------------------------------------------------------------
function vmul_vM( v, M ) // 列優先 2021/05/23 バグ修正vec4->vec3 
//---------------------------------------------------------------------
{
	//					|	00	10	20	|			// 数学的表記
	//	| x y z 1 |	X	|	01	11	21	|
	//					|	02	12	22	|
	//					|	03	13	23	|

	return vec3(
		v.x * M[0][0] +  v.y * M[0][1] +  v.z * M[0][2] +  1 * M[0][3] ,
		v.x * M[1][0] +  v.y * M[1][1] +  v.z * M[1][2] +  1 * M[1][3] ,
		v.x * M[2][0] +  v.y * M[2][1] +  v.z * M[2][2] +  1 * M[2][3] ,
	);
}

//---------------------------------------------------------------------
function vec4_vmul_Mv( M, v ) // 列優先 
//---------------------------------------------------------------------
{
	//	|	00	10	20	30	|		| x |			// 数学的表記
	//	|	01	11	21	31	|		| y	|
	//	|	02	12	22	32	|	X	| z	|
	//	|	03	13	23	33	|		| w	|

	return vec4(
		M[0][0] * v.x +  M[1][0] * v.y +  M[2][0] * v.z +  M[3][0] * v.w,
		M[0][1] * v.x +  M[1][1] * v.y +  M[2][1] * v.z +  M[3][1] * v.w,
		M[0][2] * v.x +  M[1][2] * v.y +  M[2][2] * v.z +  M[3][2] * v.w,
		M[0][3] * v.x +  M[1][3] * v.y +  M[2][3] * v.z +  M[3][3] * v.w
	);
}
//---------------------------------------------------------------------
function vmul_Mv( M, v ) // 列優先 	2021/05/07 vec3
//---------------------------------------------------------------------
{
	//	|	00	10	20	30	|		| x |			// 数学的表記
	//	|	01	11	21	31	|	X	| y	|
	//	|	02	12	22	32	|		| z	|
	//								| 1	|

	return vec3(
		M[0][0] * v.x +  M[1][0] * v.y +  M[2][0] * v.z +  M[3][0] * 1,
		M[0][1] * v.x +  M[1][1] * v.y +  M[2][1] * v.z +  M[3][1] * 1,
		M[0][2] * v.x +  M[1][2] * v.y +  M[2][2] * v.z +  M[3][2] * 1,
	);
}
//-----------------------------------------------------------------------------
function mlookat( eye, at, up=vec3(0,1,0)  )	// V マトリクスを作成
//-----------------------------------------------------------------------------
{
	if(0)
	{
		let m = midentity();
		let v = vsub( at, eye );
		let ry = Math.atan2(v.x,-v.z);
		let xy = Math.sqrt(v.x*v.x+v.z*v.z);
		let rx = Math.atan2(-v.y,xy);

		m = mmul( m, mrotx( rx ) );
		m = mmul( m, mroty( ry ) );
		m = mmul( m, mtrans( vec3( -eye.x, -eye.y, -eye.z )) );
		return m;
	}
	else
	{	// カメラ行列を生成し、逆マトリクスにする。
		let	z = normalize( vsub( eye, at ) );
		let	x = normalize( cross( up, z  ) );
		let	y = cross( z, x );

		let m = mat4(
			x.x		,	x.y		,	x.z		,	0	,
			y.x		,	y.y		,	y.z		,	0	,
			z.x		,	z.y		,	z.z		,	0	,
			eye.x	,	eye.y	,	eye.z	,	1	
		);
		return minvers(m);
	}
}

////

